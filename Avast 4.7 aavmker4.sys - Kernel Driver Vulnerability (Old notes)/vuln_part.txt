Vuln Part
=========
.text:00010D15                         vulnerable_part:                        ; CODE XREF: IOCTL_Dispatch_Routine+42j
.text:00010D15 B9 5B 00 D6 B2                          mov     ecx, 0B2D6005Bh ; copy 0xB2D6005B into ECX
.text:00010D1A 3B C1                                   cmp     eax, ecx        ; IoControlCode compare with 0xB2D6005B
.text:00010D1C 0F 87 B6 01 00 00                       ja      loc_10ED8       ; IoControlCode compare 0xB2D6005F
.text:00010D22 0F 84 A8 01 00 00                       jz      loc_10ED0
.text:00010D28 3D 30 00 D6 B2                          cmp     eax, 0B2D60030h ; IoControlCode compare with 0xB2D60030
.text:00010D2D 74 7C                                   jz      short loc_10DAB ; jump into loc_10DAB if value is zero

If IOCTL requests is match with 0xB2D60030, it will execute loc_10DAB. Offset 00010DAB belongs to EDI which is value set as zero. EBX still holds the pointer to IRP structure, and at the offset 00010DC9 a pointer to the input data is stored in ESI, referred back to Part 3. 

Beginning of dispatch routine, the InputBufferLength will store in the stack variable var_1C and then, value of the input data will compare with value 0x878. If the data length input equals with 0x878, the input will be pointed by ESI (refer offset 00010DDF). 

At the offset 00010DE2, data input will be compare and check if it is NULL. Thus, if the input is not NULL, pointer from the data will extract (00010DE6) and store the value in EAX. This pointer will store at stack variable var_48 (00010DEC). 

A check will performed again to see the data input will be pointed to EAX, with value 0xD0DEAD07 and 0x10BAD0BA. Then it will jump into offset 00010E06 which is basically our memcpy(). This memcpy() basically lead us to memory corruption. It will happen if it has these criteria:
	* IOCTL request (0xB2D60030) is sent to kernel driver via Aavmker4 service.
	* Driver code will check the the IOCTL input data length equals to 0x878.
	* If ok, driver will check the IOCTL input data that will contained value 0xD0DEAD07 and 0x10BAD0BA. 
	* Driver will corrupted or memory corruption will occured if point above match!

Data Input
===========
.text:00010DAB                         loc_10DAB:                              ; CODE XREF: IOCTL_Dispatch_Routine+3A1j
.text:00010DAB 33 FF                                   xor     edi, edi        ; edi = 0
.text:00010DAD 80 3D 0C 24 01 00 00                    cmp     byte_1240C, 0
.text:00010DB4 74 13                                   jz      short vuln_data_input ; IRP->AssociatedIrp.SystemBuffer

Vulnerable data input
======================
.text:00010DC9                         vuln_data_input:                        ; CODE XREF: IOCTL_Dispatch_Routine+428j
.text:00010DC9 8B 73 0C                                mov     esi, [ebx+0Ch]  ; IRP->AssociatedIrp.SystemBuffer
.text:00010DCC 81 7D E4 78 08 00 00                    cmp     [ebp+var_1C], 878h ; input length 0x878 (ebp+var_1C = esi), esi will be the input
.text:00010DD3 74 0A                                   jz      short loc_10DDF ; jump into loc_10DDF if zero

IOCTL compare
==============
.text:00010DDF                         loc_10DDF:                              ; CODE XREF: IOCTL_Dispatch_Routine+447j
.text:00010DDF 89 7D FC                                mov     [ebp+ms_exc.registration.TryLevel], edi
.text:00010DE2 39 3E                                   cmp     [esi], edi      ; data input = esi
.text:00010DE4 74 4E                                   jz      short loc_10E34 ; if input == NULL, jump to loc_10E34, else jump to 00010DE6
.text:00010DE6 8B 86 70 08 00 00                       mov     eax, [esi+870h] ; esi & eax pointing to input data (0x870)
.text:00010DEC 89 45 B8                                mov     [ebp+var_48], eax ; pointer to control data, and store at var_48
.text:00010DEF 81 38 07 AD DE D0                       cmp     dword ptr [eax], 0D0DEAD07h ; validating input data, eax == 0xD0DEAD07
.text:00010DF5 75 09                                   jnz     short loc_10E00 ; jump if input is not zero
.text:00010DF7 81 78 04 BA D0 BA 10                    cmp     dword ptr [eax+4], 10BAD0BAh ; validate input data
.text:00010DFE 74 06                                   jz      short memcpy_mem_corrupted ; if so, jump to loc_10E06

Memory Corruption
==================
.text:00010E06                         memcpy_mem_corrupted:                   ; CODE XREF: IOCTL_Dispatch_Routine+472j
.text:00010E06 33 D2                                   xor     edx, edx
.text:00010E08 8B 45 B8                                mov     eax, [ebp+var_48]
.text:00010E0B 89 10                                   mov     [eax], edx
.text:00010E0D 89 50 04                                mov     [eax+4], edx
.text:00010E10 83 C6 04                                add     esi, 4          ; source
.text:00010E13 B9 1A 02 00 00                          mov     ecx, 21Ah       ; length
.text:00010E18 8B 78 18                                mov     edi, [eax+18h]  ; destination
.text:00010E1B F3 A5                                   rep movsd               ; memcpy()
