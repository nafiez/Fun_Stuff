Initial dispatch routine
=========================
.text:000109B2 8B 5D 0C                                mov     ebx, [ebp+Irp]  ; ebx = IRP
.text:000109B5 8B 43 60                                mov     eax, [ebx+60h]  ; eax = CurrentStackLocation
.text:000109B8 8B 70 08                                mov     esi, [eax+8]    ; ULONG InputBufferLength = esi
.text:000109BB 89 75 E4                                mov     [ebp+var_1C], esi ; store InputBufferLength into var_1C
.text:000109BE 8B 50 04                                mov     edx, [eax+4]    ; ULONG OutputBufferLength = edx
.text:000109C1 89 55 C4                                mov     [ebp+var_3C], edx ; store OutputBufferLength into var_3C
.text:000109C4 8B 40 0C                                mov     eax, [eax+0Ch]  ; ULONG IoControlCode = eax
.text:000109C7 B9 2C 00 D6 B2                          mov     ecx, 0B2D6002Ch ; ecx = 0xB2D6002C
.text:000109CC 3B C1                                   cmp     eax, ecx        ; ecx == eax, 0xB2D6002C compare with IoControlCode
.text:000109CE 0F 87 41 03 00 00                       ja      loc_10D15       ; copy 0xB2D6005B into ECX

Input compare
=============
.text:00010D15                         loc_10D15:                              ; CODE XREF: sub_1098C+42j
.text:00010D15 B9 5B 00 D6 B2                          mov     ecx, 0B2D6005Bh ; copy 0xB2D6005B into ECX
.text:00010D1A 3B C1                                   cmp     eax, ecx        ; IoControlCode compare with 0xB2D6005B
.text:00010D1C 0F 87 B6 01 00 00                       ja      loc_10ED8       ; IoControlCode compare 0xB2D6005F
.text:00010D22 0F 84 A8 01 00 00                       jz      loc_10ED0
.text:00010D28 3D 30 00 D6 B2                          cmp     eax, 0B2D60030h ; IoControlCode compare with 0xB2D60030
.text:00010D2D 74 7C                                   jz      short loc_10DAB ; if so -> loc_10DAB

Set EDI to zero
===============
.text:00010DAB                         loc_10DAB:                              ; CODE XREF: sub_1098C+3A1j
.text:00010DAB 33 FF                                   xor     edi, edi        ; edi = 0
.text:00010DAD 80 3D 0C 24 01 00 00                    cmp     byte_1240C, 0
.text:00010DB4 74 13                                   jz      short loc_10DC9 ; (jump to 10DC9), IRP->AssociatedIrp.SystemBuffer

Pointer to IRP structure
========================
.text:00010DC9                         loc_10DC9:                              		; CODE XREF: sub_1098C+428j
.text:00010DC9 8B 73 0C                                mov     esi, [ebx+0Ch]  		; IRP->AssociatedIrp.SystemBuffer
.text:00010DCC 81 7D E4 78 08 00 00                    cmp     [ebp+var_1C], 878h 	; input length 0x878 (ebp+var_1C = esi), esi will be the input
.text:00010DD3 74 0A                                   jz      short loc_10DDF 		; if so -> loc_10DDF

Working Bug
============
InputBufferLength request is stored in stack variable var_1C;
	.text:000109BB 89 75 E4                                mov     [ebp+var_1C], esi ; store InputBufferLength into var_1C

Length of the input data, then compare with value 0x878;
	.text:00010DCC 81 7D E4 78 08 00 00                    cmp     [ebp+var_1C], 878h 	; input length 0x878 (ebp+var_1C = esi), esi will be the input


Data Length == 0x878
=====================
.text:00010DDF                         loc_10DDF:                              ; CODE XREF: sub_1098C+447j
.text:00010DE2 39 3E                                   cmp     [esi], edi      ; data input = esi
.text:00010DE4 74 4E                                   jz      short loc_10E34 ; if input == NULL, jump to loc_10E34, else jump to 00010DE6
.text:00010DE6 8B 86 70 08 00 00                       mov     eax, [esi+870h] ; esi & eax pointing to input data (0x870)
.text:00010DEC 89 45 B8                                mov     [ebp+var_48], eax ; pointer to control data, and store at var_48
.text:00010DEF 81 38 07 AD DE D0                       cmp     dword ptr [eax], 0D0DEAD07h ; validating input data, eax == 0xD0DEAD07
.text:00010DF5 75 09                                   jnz     short loc_10E00 ; jump if input is not zero
.text:00010DF7 81 78 04 BA D0 BA 10                    cmp     dword ptr [eax+4], 10BAD0BAh ; validate input data
.text:00010DFE 74 06                                   jz      short loc_10E06 ; if so, jump to loc_10E06

Jump from 10DFE
================
.text:00010E06                         loc_10E06:                              ; CODE XREF: sub_1098C+472j
.text:00010E06 33 D2                                   xor     edx, edx
.text:00010E08 8B 45 B8                                mov     eax, [ebp+var_48]
.text:00010E0B 89 10                                   mov     [eax], edx
.text:00010E0D 89 50 04                                mov     [eax+4], edx
.text:00010E10 83 C6 04                                add     esi, 4          ; source
.text:00010E13 B9 1A 02 00 00                          mov     ecx, 21Ah       ; length
.text:00010E18 8B 78 18                                mov     edi, [eax+18h]  ; destination
.text:00010E1B F3 A5                                   rep movsd               ; memcpy()




